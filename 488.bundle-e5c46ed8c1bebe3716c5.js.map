{"version":3,"file":"488.bundle-e5c46ed8c1bebe3716c5.js","mappings":"kIAGO,MAAMA,EAAW,CAACC,EAAMC,KAC7B,IAAIC,EAGJ,MAAO,CACLC,YAAYC,GACVC,aAAaH,GAEbA,EAAUI,YAAW,KACnBN,EAAKO,MAAMC,KAAMJ,KAChBH,KAEJE,WCTC,cAACM,GAAiB,EAIlBC,EAAe,oDACfC,EACJ,uEACIC,EAAgB,eAChBC,EAAuB,eACvBC,EAAwB,CAAC,OAAQ,WAAY,QAAS,MAAO,MAAO,SAAU,SAClF,QAAS,YAELC,EAAuBC,GAAkB,UAATA,GAA6B,aAATA,EAGpDC,EAAmB,CACvBC,OAAQ,CAACC,EAAOC,IACA,KAAVD,OACsBE,IAAjBD,EACHA,EACA,KAGCE,OAAOH,GAGhBI,QAAS,CAACJ,EAAOC,IAAiBH,EAAiBC,OAAOC,EAAOC,GAEjEI,OAASL,GAAUA,EAAMM,OAEzBC,KAAOP,GAAUF,EAAiBO,OAAOL,GAEzCQ,SAAWR,GAAUF,EAAiBO,OAAOL,IAIzCS,EAAmB,CACvBV,OAASC,GACAR,EAAoBkB,KAAKV,GAGlCI,QAAUJ,GACDN,EAAqBgB,KAAKV,IAQ/BW,EAAoB,CACxBZ,OAASC,GACU,KAAVA,GAAgBT,EAAamB,KAAKV,GAG3CI,QAAUJ,GACS,KAAVA,GAAgBP,EAAciB,KAAKV,GAG5CK,OAAQ,CAACL,EAAOY,IAGU,iBAFxBA,EAAWA,GAAY,KAGdA,EAASN,SAAWN,EAAMM,OAMrCC,KAAM,CAACP,EAAOY,IAAaD,EAAkBN,OAAOL,EAAOY,GAE3DJ,SAAU,CAACR,EAAOY,IAAaD,EAAkBN,OAAOL,EAAOY,IAGlD,MAAMC,UAAc,YACjCC,eAAe7B,GACb8B,SAAS9B,GAETI,KAAK2B,MAAQ,CACXhB,MAAOX,KAAK4B,MAAMjB,MAElBY,SAAUvB,KAAK4B,MAAMjB,OAGvBX,KAAK6B,SAAW,KAChB7B,KAAK8B,OAAS,KACd9B,KAAK+B,aAAe/B,KAAK+B,aAAaC,KAAKhC,MAE3CA,KAAKiC,oBACLjC,KAAKkC,kBAGPC,mBAAmBC,GACjB,MAAMC,EAAkBrC,KAAK4B,MAAMrC,WAAa6C,EAAU7C,SAC1D,IAAI+C,EACAC,GAEAF,GAAmBrC,KAAK4B,MAAMC,WAAaO,EAAUP,YACvD7B,KAAKiC,oBAELK,GAAkB,IAGhBD,GAAmBrC,KAAK4B,MAAME,SAAWM,EAAUN,UACrD9B,KAAKkC,kBAELK,GAAgB,GAKbvC,KAAK4B,MAAMY,gBAAkBxC,KAAK4B,MAAMjB,QAAUX,KAAK2B,MAAMJ,UAKvDe,GAAmBC,IAC5BvC,KAAKyC,cALLzC,KAAK0C,SAAS,CACZ/B,MAAOX,KAAK4B,MAAMjB,MAClBY,SAAUvB,KAAK4B,MAAMjB,QAO3BoB,aAAaY,GACX,MAAM,KAACnC,EAAI,eAAEgC,EAAc,eAAEI,EAAc,SAAEf,GAAY7B,KAAK4B,MACxDjB,EAAQJ,EAAoBC,GAC9BmC,EAAEE,OAAOC,QACTH,EAAEE,OAAOlC,MACPoC,EAAiB3B,EAAiBZ,GAExC,GAAIuC,IAAmBA,EAAepC,GACpC,OAGFX,KAAK0C,SAAS,CACZ/B,MAAAA,IAGF,MAAMqC,EAAmB1B,EAAkBd,GAE3C,GAAIwC,IAAqBA,EAAiBrC,EAAOX,KAAK2B,MAAMJ,UAC1D,OAGF,MAAM0B,EAAaxC,EAAiBD,GAC9B0C,EAAkBD,EACpBA,EAAWtC,EAAOX,KAAK4B,MAAMhB,cAC7BD,EAEJX,KAAK0C,SAAS,CACZnB,SAAU2B,IAGPrB,KAIAW,GAAkBI,GACrBA,IAGF5C,KAAK6B,SAASqB,IAGhBjB,oBACE,MAAMkB,EAAgBnD,KAAKoD,mBAE3BpD,KAAK6B,SAA6B,IAAlBsB,EACZnD,KAAK4B,MAAMC,SACXtC,EAASS,KAAK4B,MAAMC,SAAUsB,GAGpCC,mBACE,MAAsC,iBAAxBpD,KAAK4B,MAAMrC,SACrBS,KAAK4B,MAAMrC,SACXgB,EAAoBP,KAAK4B,MAAMpB,MA1KX,EA4KoB,iBAA/BR,KAAKqD,QAAQF,cAClBnD,KAAKqD,QAAQF,cA9KD,IAkLtBjB,kBACE,IAAKlC,KAAK4B,MAAME,OACd,YAAa9B,KAAK8B,OAAS,MAG7B,MAAMqB,EAAgBnD,KAAKoD,mBAE3BpD,KAAK8B,OAA2B,IAAlBqB,EACVnD,KAAK4B,MAAME,OACXvC,EAASS,KAAK4B,MAAME,OAAQqB,GAGlCG,SACE,MAAM,OAACC,EAAM,KAAE/C,EAAI,SAAEgD,EAAQ,YAAEC,EAAW,UAAEC,EAAS,SAAEC,EAAQ,SAC7DC,EAAQ,UAAEC,EAAS,eAAEC,EAAc,WAAEC,GAAc/D,KAAK4B,MACpDjB,GAAQ,QAAMX,KAAK2B,MAAMhB,OAC3BX,KAAK2B,MAAMhB,MACX,GACEqD,IAAcT,KAAYA,EAAOU,OAEvC,OAAOhE,EACL,OACA,CACEyD,UAAW,iBAAiBM,EAAY,aAAe,MAAMN,OAE7DF,GAAYvD,EAAc,OAAQ,KAAM,KAC1CA,EACW,aAATO,EAAsBA,EAAO,QAC7B0D,OAAOC,OACL,GACAJ,EACA,CACEpD,MAAAA,EACAmC,QAASvC,EAAoBC,IAASG,EACtCH,KAAMF,EAAsB8D,SAAS5D,GACjCA,EACA,OACJiD,YAAAA,EACA5B,SAAU7B,KAAK+B,aACfD,OAAQ9B,KAAK8B,OACb6B,SAAAA,EACAC,SAAAA,EACAC,UAAAA,EACAH,UAAWI,KAEjBE,GAAa/D,EACX,OACA,KACAsD,EAAOc,KAAI,CAACC,EAAOC,IAAMtE,EAAc,OAAQ,CAACuE,IAAKD,GAAID,QAIjE9C,EAAMiD,UAAY,CAChB9D,MAAO,MACPC,aAAc,MACdJ,KAAM,QAAgB,IAAIF,EAAuB,SAAU,SAAU,UAAW,aAChFiD,OAAQ,QACRf,eAAgB,OAChBgB,SAAU,OACVC,YAAa,SACbC,UAAW,SACXI,eAAgB,SAChBvE,SAAU,SACVsC,SAAU,OACVC,OAAQ,OACRc,eAAgB,OAChBe,SAAU,OACVC,SAAU,OACVC,UAAW,OACXE,WAAY,UAGdvC,EAAMkD,aAAe,CACnBlE,KAAM,OACNkD,UAAW,IAGblC,EAAMmD,aAAe,CACnBxB,cAAe,W,8DCrQV,MAAM3B,GAAQ,SAAW,SAAUoD,EAAS,IACjD,MAAM,KAACC,EAAI,SAAEC,EAAQ,KAAEC,EAAI,QAAEC,EAAO,OAAEC,EAAM,KAAEC,EAAI,aAAEC,EAAY,4BAC9DC,EAA2B,uBAAEC,GAA0BT,EACzD,IAAI,SAACU,EAAQ,SAAEC,EAAQ,SAAEC,EAAQ,aAAE5E,EAAY,WAAE6E,GAAcb,EAC3Dc,EAAc,IAAIC,IAClBC,GAAqB,EAEzB,MAAMC,EAAQ,CACZhB,KAAAA,EACAG,QAAAA,EACAc,SAAS,EACTC,WAAW,EACXvD,gBAAgB,EAChBwD,aAAa,EACbhC,WAAW,EACXT,OAAQ,KACR0B,OAAAA,EACArE,aAAAA,EAEA,uBACE,OAASyE,GAA0BQ,EAAMI,YAClCb,GAA+BS,EAAMrD,gBAG9C,gBACE,OAAOqD,EAAM7B,WAAa6B,EAAMK,mBAIpCL,EAAMV,aAAeA,EAErB,MAkCMgB,EAAiBC,IACrB,IAAI,QAAMA,EAAMvB,MAAO,CACrB,GAAIa,EAAYW,IAAID,EAAMvB,MACxB,MAAM,IAAIyB,MAAM,yBAAyBF,EAAMvB,QAGjDa,EAAYa,IAAIH,EAAMvB,KAAMuB,KAIhCP,EAAMhE,SAAY2E,IAChBZ,GAAqB,EAErBL,EAASkB,KAAKZ,EAAOW,GACrBX,EAAMa,qBACNb,EAAMX,KAAKyB,cACXC,IACAf,EAAMX,KAAKJ,SAAS,CAAC+B,MAAO,SAAUhE,OAAQgD,IAC9CiB,KAGFjB,EAAMa,mBAAqB,KACzBb,EAAMrD,eAAiBoD,KACfJ,GAAYA,EAASuB,MAAMX,GAAUA,EAAM5D,iBAE/CqD,EAAMZ,QACRY,EAAMZ,OAAOyB,sBAIjBb,EAAMc,YAAc,KAClB,IAAIK,GAAmB,EAEnBxB,GACFA,EAASyB,SAASb,IAChBA,EAAMO,cAEFP,EAAMN,UACRkB,GAAmB,MAKzBnB,EAAMC,QAAUkB,GAAoBnB,EAAMP,aAAeO,EAAMjF,cAGjE,MAAMgG,EAAgB,KACpB,IAAIM,EAAerB,EAEnB,GACEqB,EAAanB,WAAY,EACzBmB,EAAeA,EAAajC,aACrBiC,IAGXrB,EAAMf,SAAW,EAAE+B,MAAAA,EAAOhE,OAAAA,EAASgD,GAAS,MAC1C,MAAMtC,EAAS,GAOf,OALAsC,EAAMtC,OAAS,KACfsC,EAAM7B,WAAY,GAIX,QAASwB,GAAYA,EAASnB,KAAK+B,GAAUA,EAAMtB,SAAS,CAAC+B,MAAAA,EAAOhE,OAAAA,OAAW,KAChF2C,GACFA,EAASyB,SAASb,IACZA,EAAMpC,WACRT,EAAO4D,QAAQf,EAAM7C,YAKpB,QAASuB,IAAY,QAASA,EAAS2B,KAAKZ,EAAO,CAACA,MAAAA,EAAOgB,MAAAA,EAAOhE,OAAAA,KACtEyB,IACKA,IACE8C,MAAMC,QAAQ/C,GAChBf,EAAO4D,QAAQ7C,GAEff,EAAO4D,KAAK7C,OAGdA,IACFf,EAAO4D,MAAK,QAAOG,EAAKC,sBACpBD,EAAKC,qBAAqBjD,GAC1BgD,EAAKC,0BACP,KACEhE,EAAOU,QACT4B,EAAMtC,OAASA,EACfsC,EAAM7B,WAAY,IAIlB6B,EAAMtC,OAAS,KACfsC,EAAM7B,WAAY,UAM5B,MAAM8C,EAAmB,KACvB,IAAIU,EAAsB3B,EAE1B,IACM,QAAO2B,EAAoBrC,eAC7BqC,EAAoBrC,aAAa,CAACtC,OAAQgD,EAAOA,MAAO2B,IAG1DA,EAAsBA,EAAoBvC,aACnCuC,IAGX3B,EAAMjD,eAAiB,KACrB,IAAI6E,EAAe5B,EAEnBD,GAAqB,EAErB,GACE6B,EAAajF,gBAAiB,EAC9BiF,EAAeA,EAAaxC,aACrBwC,IAGX5B,EAAM/D,OAAS,KACb8E,IACAf,EAAMX,KAAKJ,SAAS,CAAC+B,MAAO,OAAQhE,OAAQgD,KAG9CA,EAAM6B,OAAS,IAAI9H,KACbiG,EAAM8B,YAIV9B,EAAMG,aAAc,EAEpBH,EAAMf,SAAS,CAAC+B,MAAO,WAGnBhB,EAAMb,SAAWa,EAAMb,QAAQ0C,SAAW7B,EAAM8B,WAClD9B,EAAMb,QAAQ0C,OAAO3H,MAAM8F,EAAOjG,KAItCiG,EAAM+B,WAAY,SAAO,KACvB,GAAIpC,EAAU,CACZ,IAAKE,EAAYmC,MAAQnC,EAAYmC,OAASrC,EAASvB,OACrD,OAAOuB,EAASnB,KAAK+B,GAAUA,EAAMwB,cAGvC,MAAME,EAAS,GAMf,OAJAtC,EAASyB,SAASb,IAChB0B,EAAO1B,EAAMvB,MAAQuB,EAAMwB,eAGtBE,EAGT,OAAOjC,EAAMP,cAGfO,EAAMkC,MAAQ,EAAElF,OAAAA,EAASgD,GAAS,MAC5BhD,IAAWgD,GAASA,EAAMK,mBAI1BV,GACFA,EAASyB,SAASb,GAAUA,EAAM2B,MAAM,CAAClF,OAAAA,MAG3CmF,IAEInF,IAAWgD,IACbA,EAAMX,KAAKyB,cACXd,EAAMX,KAAKJ,SAAS,CAAC+B,MAAO,QAAShE,OAAQgD,IAGzCA,EAAMb,SAAWa,EAAMb,QAAQ+C,QAAUlC,EAAMK,kBACjDL,EAAMb,QAAQ+C,MAAMtB,KAAKZ,MAK/B,MAAMmC,EAAgB,KACpBzC,EAASkB,KAAKZ,EAAOA,EAAMjF,cAE3BiF,EAAMG,aAAc,EACpBH,EAAME,WAAY,GAiHpB,OA9GAF,EAAMoC,MAAQ,EAAEpF,OAAAA,EAASgD,GAAS,MAC5BhD,IAAWgD,GAASA,EAAMK,mBAI1BV,GACFA,EAASyB,SAASb,GAAUA,EAAM6B,MAAM,CAACpF,OAAAA,MAGvC+B,EAAOsD,eAAe,cACxBrC,EAAMjF,aAAe6E,EACZI,EAAMjF,eACfiF,EAAMjF,aAAe,MAGvBoH,IAEInF,IAAWgD,IACbA,EAAMX,KAAKyB,cACXd,EAAMX,KAAKJ,SAAS,CAAC+B,MAAO,QAAShE,OAAQgD,IAGzCA,EAAMb,SAAWa,EAAMb,QAAQiD,QAAUpC,EAAMK,kBACjDL,EAAMb,QAAQiD,MAAMxB,KAAKZ,MAK/BA,EAAMsC,KAAM,SAAQtD,GAASa,EAAYyC,IAAItD,KAE7CgB,EAAMuC,IAAM,CAACC,EAAaC,KACxBzC,EAAM0C,SAAS,IAAI/G,EAAM6G,GAAcC,IAGzCzC,EAAM0C,SAAW,CAACC,EAAYF,KAC5B,GAAIE,EAAWvD,OACb,MAAM,IAAIqB,MAAM,yCAGlBkC,EAAWvD,OAASY,EAEpB2C,EAAWC,QAAQ5C,EAAMX,MAEpBM,IACHK,EAAML,SAAWA,EAAW,KAG1B,QAAM8C,GACR9C,EAASkD,OAAOJ,EAAO,EAAGE,GAE1BhD,EAAS2B,KAAKqB,GAGhBrC,EAAcqC,IACd,QAAiB3C,EAAO2C,GAExB3C,EAAMa,qBACNb,EAAMX,KAAKyB,cACXd,EAAMX,KAAKJ,SAAS,CAAC+B,MAAO,MAAOhE,OAAQgD,KAG7CA,EAAM4C,QAAWvD,IACfW,EAAMX,KAAOA,EAETM,GACFA,EAASyB,SAASb,GAAUA,EAAMqC,QAAQvD,MAI9CW,EAAM8C,OAAS,KACb,IAAK9C,EAAMZ,OACT,MAAM,IAAIqB,MAAM,oCAGlBT,EAAMZ,OAAO2D,YAAY/C,IAG3BA,EAAM+C,YAAexC,IACnB,IAAKZ,EACH,MAAM,IAAIc,MAAM,iCAGlB,MAAMuC,EAAarD,EAASsD,QAAQ1C,GAEpC,IAAoB,IAAhByC,EACF,MAAM,IAAIvC,MAAM,iCAGlBd,EAASkD,OAAOG,EAAY,IAExB,QAAMzC,EAAMvB,OACda,EAAYqD,OAAO3C,EAAMvB,OAG3B,QAAoBgB,EAAOO,GAE3BA,EAAMnB,OAAS,KAEfmB,EAAMqC,QAAQrC,GACdP,EAAMa,qBACNb,EAAMX,KAAKyB,cACXd,EAAMX,KAAKJ,SAAS,CAAC+B,MAAO,SAAUhE,OAAQgD,KApU9B,MAKhB,GAJAA,EAAMX,KAAOA,GAAQW,EAErBA,EAAMP,UAAW,QAAOA,IAEnBO,EAAMP,WAAcC,EACvB,MAAM,IAAIe,MAAM,sEAGlB,GAAIT,EAAMP,SAAU,CAClB,GAAIV,EAAOsD,eAAe,gBACxB,MAAM,IAAI5B,MAAM,6DAGlBT,EAAMjF,aAAeiF,EAAMP,gBAG3BO,EAAMlF,MAAQkF,EAAMjF,aAEpBiF,EAAMP,UAAW,SAAO,IAAMO,EAAMlF,QAEpC4E,EAAYiB,GAAQX,EAAMlF,MAAQ6F,EAGpCX,EAAML,SAAWA,EAAWA,GAAYA,EAASnB,KAAK+B,GACpD,IAAI5E,EAAM0C,OAAOC,OAAO,GAAIiC,EAAO,CAAClB,KAAMW,EAAMX,KAAMD,OAAQY,OAE5DL,GACFA,EAASyB,QAAQd,IAGnB,QAAQnB,IAwSVgE,GAEIjE,GACFA,EAAK0B,KAAKZ,EAAO,CAACA,MAAAA,IAGbA,KAGHyB,GAAO,SAAW,SAAU1C,GAChC,MAAMM,EAAO,IAAI1D,EAAMoD,GAIvB,OAFAM,EAAKJ,SAAS,CAAC+B,MAAO,SAEf3B,KAGT,IAEAoC,EAAKC,qBAAuB","sources":["webpack:///./node_modules/crizmas-components/src/utils.js","webpack:///./node_modules/crizmas-components/src/components/input.js","webpack:///./node_modules/crizmas-form/src/form.js"],"sourcesContent":["let fitContentValue;\nlet stickyValue;\n\nexport const debounce = (func, delay) => {\n  let timeout;\n\n  // make sure the function is not a constructor\n  return ({\n    function(...args) {\n      clearTimeout(timeout);\n\n      timeout = setTimeout(() => {\n        func.apply(this, args);\n      }, delay);\n    }\n  }).function;\n};\n\nexport const getFitContentValue = () => {\n  if (!fitContentValue) {\n    fitContentValue = detectFitContentValue();\n  }\n\n  return fitContentValue;\n};\n\nconst detectFitContentValue = () => {\n  const div = document.createElement('div');\n\n  div.style.width = 'fit-content';\n\n  if (div.style.width === 'fit-content') {\n    return 'fit-content';\n  }\n\n  return '-moz-fit-content';\n};\n\nexport const getStickyValue = () => {\n  if (!stickyValue) {\n    stickyValue = detectStickyValue();\n  }\n\n  return stickyValue;\n};\n\nconst detectStickyValue = () => {\n  const div = document.createElement('div');\n\n  div.style.position = 'sticky';\n\n  if (div.style.position === 'sticky') {\n    return 'sticky';\n  }\n\n  // Safari requires the prefix\n  return '-webkit-sticky';\n};\n","import React from 'react';\nimport propTypes from 'prop-types';\nimport {isVal} from 'crizmas-mvc';\n\nimport {debounce} from '../utils.js';\n\nconst {createElement} = React;\n\nconst defaultDebounce = 100;\nconst defaultBoolDebounce = 0;\nconst numberRegExp = /^(-|\\+)?(((\\d+(\\.\\d*)?)|(\\.\\d+))(e(-|\\+)?\\d+)?)$/i;\nconst partialNumberRegExp =\n  /^(-|\\+)?((\\d*(\\.\\d*)?)|((((\\d+(\\.\\d*)?)|(\\.\\d+))(e(-|\\+)?\\d*)?)?))$/i;\nconst integerRegExp = /^(-|\\+)?\\d+$/;\nconst partialIntegerRegExp = /^(-|\\+)?\\d*$/;\nconst allowedHtmlInputTypes = ['text', 'password', 'email', 'url', 'tel', 'search', 'hidden',\n  'radio', 'checkbox'];\n\nconst isBoolHtmlInputType = (type) => type === 'radio' || type === 'checkbox';\n\n// normalizers convert the final string to the expected value\nconst valuesNormalizer = {\n  number: (value, initialValue) => {\n    if (value === '') {\n      return initialValue === undefined\n        ? initialValue\n        : null;\n    }\n\n    return Number(value);\n  },\n\n  integer: (value, initialValue) => valuesNormalizer.number(value, initialValue),\n\n  string: (value) => value.trim(),\n\n  text: (value) => valuesNormalizer.string(value),\n\n  textarea: (value) => valuesNormalizer.string(value)\n};\n\n// type guards disallow unexpected characters in the input\nconst valueTypesGuards = {\n  number: (value) => {\n    return partialNumberRegExp.test(value);\n  },\n\n  integer: (value) => {\n    return partialIntegerRegExp.test(value);\n  }\n};\n\n// change guards prevent calling the onChange handler with temporary values.\n// an example is 3e for real numbers. the e character must be allowed because\n// the user could enter 3e2, but the intermediary value 3e must not be sent\n// to the client.\nconst valueChangeGuards = {\n  number: (value) => {\n    return value === '' || numberRegExp.test(value);\n  },\n\n  integer: (value) => {\n    return value === '' || integerRegExp.test(value);\n  },\n\n  string: (value, oldValue) => {\n    oldValue = oldValue || '';\n\n    if (typeof oldValue === 'string') {\n      return oldValue.trim() !== value.trim();\n    }\n\n    return true;\n  },\n\n  text: (value, oldValue) => valueChangeGuards.string(value, oldValue),\n\n  textarea: (value, oldValue) => valueChangeGuards.string(value, oldValue)\n};\n\nexport default class Input extends React.Component {\n  constructor(...args) {\n    super(...args);\n\n    this.state = {\n      value: this.props.value,\n      // last normalized value\n      oldValue: this.props.value\n    };\n\n    this.onChange = null;\n    this.onBlur = null;\n    this.initOnChange = this.initOnChange.bind(this);\n\n    this.setOnChangeMethod();\n    this.setOnBlurMethod();\n  }\n\n  componentDidUpdate(prevProps) {\n    const debounceChanged = this.props.debounce !== prevProps.debounce;\n    let onChangeChanged;\n    let onBlurChanged;\n\n    if (debounceChanged || this.props.onChange !== prevProps.onChange) {\n      this.setOnChangeMethod();\n\n      onChangeChanged = true;\n    }\n\n    if (debounceChanged || this.props.onBlur !== prevProps.onBlur) {\n      this.setOnBlurMethod();\n\n      onBlurChanged = true;\n    }\n\n    // we must ignore the same value when we have an intermediary string representation\n    // like 3.20 (after the 0 there can be a new decimal)\n    if (!this.props.isInputPending && this.props.value !== this.state.oldValue) {\n      this.setState({\n        value: this.props.value,\n        oldValue: this.props.value\n      });\n    } else if (onChangeChanged || onBlurChanged) {\n      this.forceUpdate();\n    }\n  }\n\n  initOnChange(e) {\n    const {type, isInputPending, onStartPending, onChange} = this.props;\n    const value = isBoolHtmlInputType(type)\n      ? e.target.checked\n      : e.target.value;\n    const valueTypeGuard = valueTypesGuards[type];\n\n    if (valueTypeGuard && !valueTypeGuard(value)) {\n      return;\n    }\n\n    this.setState({\n      value\n    });\n\n    const valueChangeGuard = valueChangeGuards[type];\n\n    if (valueChangeGuard && !valueChangeGuard(value, this.state.oldValue)) {\n      return;\n    }\n\n    const normalizer = valuesNormalizer[type];\n    const normalizedValue = normalizer\n      ? normalizer(value, this.props.initialValue)\n      : value;\n\n    this.setState({\n      oldValue: normalizedValue\n    });\n\n    if (!onChange) {\n      return;\n    }\n\n    if (!isInputPending && onStartPending) {\n      onStartPending();\n    }\n\n    this.onChange(normalizedValue);\n  }\n\n  setOnChangeMethod() {\n    const inputDebounce = this.getInputDebounce();\n\n    this.onChange = inputDebounce === 0\n      ? this.props.onChange\n      : debounce(this.props.onChange, inputDebounce);\n  }\n\n  getInputDebounce() {\n    return typeof this.props.debounce === 'number'\n      ? this.props.debounce\n      : isBoolHtmlInputType(this.props.type)\n        ? defaultBoolDebounce\n        : typeof this.context.inputDebounce === 'number'\n          ? this.context.inputDebounce\n          : defaultDebounce;\n  }\n\n  setOnBlurMethod() {\n    if (!this.props.onBlur) {\n      return void (this.onBlur = null);\n    }\n\n    const inputDebounce = this.getInputDebounce();\n\n    this.onBlur = inputDebounce === 0\n      ? this.props.onBlur\n      : debounce(this.props.onBlur, inputDebounce);\n  }\n\n  render() {\n    const {errors, type, required, placeholder, className, readOnly,\n      disabled, autoFocus, inputClassName, inputProps} = this.props;\n    const value = isVal(this.state.value)\n      ? this.state.value\n      : '';\n    const hasErrors = !!errors && !!errors.length;\n\n    return createElement(\n      'span',\n      {\n        className: `crizmas-input ${hasErrors ? 'has-errors' : ''} ${className}`\n      },\n      !!required && createElement('span', null, '*'),\n      createElement(\n        type === 'textarea' ? type : 'input',\n        Object.assign(\n          {},\n          inputProps,\n          {\n            value,\n            checked: isBoolHtmlInputType(type) && value,\n            type: allowedHtmlInputTypes.includes(type)\n              ? type\n              : 'text',\n            placeholder,\n            onChange: this.initOnChange,\n            onBlur: this.onBlur,\n            readOnly,\n            disabled,\n            autoFocus,\n            className: inputClassName\n          })),\n      hasErrors && createElement(\n        'span',\n        null,\n        errors.map((error, i) => createElement('span', {key: i}, error))));\n  }\n}\n\nInput.propTypes = {\n  value: propTypes.any,\n  initialValue: propTypes.any,\n  type: propTypes.oneOf([...allowedHtmlInputTypes, 'string', 'number', 'integer', 'textarea']),\n  errors: propTypes.array,\n  isInputPending: propTypes.bool,\n  required: propTypes.bool,\n  placeholder: propTypes.string,\n  className: propTypes.string,\n  inputClassName: propTypes.string,\n  debounce: propTypes.number,\n  onChange: propTypes.func,\n  onBlur: propTypes.func,\n  onStartPending: propTypes.func,\n  readOnly: propTypes.bool,\n  disabled: propTypes.bool,\n  autoFocus: propTypes.bool,\n  inputProps: propTypes.object\n};\n\nInput.defaultProps = {\n  type: 'text',\n  className: ''\n};\n\nInput.contextTypes = {\n  inputDebounce: propTypes.number\n};\n","import {controller, observe, ignore, addObservedChild, removeObservedChild, isVal, isFunc,\n  awaitFor, awaitAll} from 'crizmas-mvc';\n\nexport const Input = controller(function (config = {}) {\n  const {name, validate, init, actions, parent, root, onFormChange,\n    preventInputPendingBlocking, preventPendingBlocking} = config;\n  let {getValue, setValue, children, initialValue, clearValue} = config;\n  let childrenMap = new Map();\n  let isSelfInputPending = false;\n\n  const input = {\n    name,\n    actions,\n    isDirty: false,\n    isTouched: false,\n    isInputPending: false,\n    isSubmitted: false,\n    hasErrors: false,\n    errors: null,\n    parent,\n    initialValue,\n\n    get isPendingBlocked() {\n      return (!preventPendingBlocking && input.isPending)\n        || (!preventInputPendingBlocking && input.isInputPending);\n    },\n\n    get isBlocked() {\n      return input.hasErrors || input.isPendingBlocked;\n    }\n  };\n\n  input.onFormChange = onFormChange;\n\n  const initInput = () => {\n    input.root = root || input;\n\n    input.getValue = ignore(getValue);\n\n    if (!input.getValue !== !setValue) {\n      throw new Error('getValue and setValue must be either both provided or both absent.');\n    }\n\n    if (input.getValue) {\n      if (config.hasOwnProperty('initialValue')) {\n        throw new Error('Cannot provide an initial value if getValue was provided.');\n      }\n\n      input.initialValue = input.getValue();\n    } else {\n      // input.value must not be created if a getValue is passed\n      input.value = input.initialValue;\n\n      input.getValue = ignore(() => input.value);\n      // if getValue is absent then setValue is absent\n      setValue = (val) => input.value = val;\n    }\n\n    input.children = children = children && children.map((child) =>\n      new Input(Object.assign({}, child, {root: input.root, parent: input})));\n\n    if (children) {\n      children.forEach(addChildToMap);\n    }\n\n    observe(actions);\n  };\n\n  const addChildToMap = (child) => {\n    if (isVal(child.name)) {\n      if (childrenMap.has(child.name)) {\n        throw new Error(`Duplicate child name: ${child.name}`);\n      }\n\n      childrenMap.set(child.name, child);\n    }\n  };\n\n  input.onChange = (val) => {\n    isSelfInputPending = false;\n\n    setValue.call(input, val);\n    input.markAsInputPending();\n    input.root.markAsDirty();\n    markAsTouched();\n    input.root.validate({event: 'change', target: input});\n    callOnFormChange();\n  };\n\n  input.markAsInputPending = () => {\n    input.isInputPending = isSelfInputPending\n      || (!!children && children.some((child) => child.isInputPending));\n\n    if (input.parent) {\n      input.parent.markAsInputPending();\n    }\n  };\n\n  input.markAsDirty = () => {\n    let hasDirtyChildren = false;\n\n    if (children) {\n      children.forEach((child) => {\n        child.markAsDirty();\n\n        if (child.isDirty) {\n          hasDirtyChildren = true;\n        }\n      });\n    }\n\n    input.isDirty = hasDirtyChildren || input.getValue() !== input.initialValue;\n  };\n\n  const markAsTouched = () => {\n    let touchedInput = input;\n\n    do {\n      touchedInput.isTouched = true;\n      touchedInput = touchedInput.parent;\n    } while (touchedInput);\n  };\n\n  input.validate = ({event, target = input} = {}) => {\n    const errors = [];\n\n    input.errors = null;\n    input.hasErrors = false;\n\n    // no child should reject as, below, the validate on the current item\n    // is caught and the error is set to the generic error\n    return awaitAll(children && children.map((child) => child.validate({event, target})), () => {\n      if (children) {\n        children.forEach((child) => {\n          if (child.hasErrors) {\n            errors.push(...child.errors);\n          }\n        });\n      }\n\n      return awaitFor(validate && awaitFor(validate.call(input, {input, event, target}),\n        (error) => {\n          if (error) {\n            if (Array.isArray(error)) {\n              errors.push(...error);\n            } else {\n              errors.push(error);\n            }\n          }\n        }, (error) => {\n          errors.push(isFunc(Form.asyncValidationError)\n            ? Form.asyncValidationError(error)\n            : Form.asyncValidationError);\n        }), () => {\n          if (errors.length) {\n            input.errors = errors;\n            input.hasErrors = true;\n          } else {\n            // even though we set the errors to null before awaiting, we need to set them again\n            // because it's possible that there was another validation done in the meantime\n            input.errors = null;\n            input.hasErrors = false;\n          }\n        });\n    });\n  };\n\n  const callOnFormChange = () => {\n    let changeHandlingInput = input;\n\n    do {\n      if (isFunc(changeHandlingInput.onFormChange)) {\n        changeHandlingInput.onFormChange({target: input, input: changeHandlingInput});\n      }\n\n      changeHandlingInput = changeHandlingInput.parent;\n    } while (changeHandlingInput);\n  };\n\n  input.onStartPending = () => {\n    let pendingInput = input;\n\n    isSelfInputPending = true;\n\n    do {\n      pendingInput.isInputPending = true;\n      pendingInput = pendingInput.parent;\n    } while (pendingInput);\n  };\n\n  input.onBlur = () => {\n    markAsTouched();\n    input.root.validate({event: 'blur', target: input});\n  };\n\n  input.submit = (...args) => {\n    if (input.isBlocked) {\n      return;\n    }\n\n    input.isSubmitted = true;\n\n    input.validate({event: 'submit'});\n\n    // after validation must recheck if it's blocked\n    if (input.actions && input.actions.submit && !input.isBlocked) {\n      input.actions.submit.apply(input, args);\n    }\n  };\n\n  input.getResult = ignore(() => {\n    if (children) {\n      if (!childrenMap.size || childrenMap.size !== children.length) {\n        return children.map((child) => child.getResult());\n      }\n\n      const result = {};\n\n      children.forEach((child) => {\n        result[child.name] = child.getResult();\n      });\n\n      return result;\n    }\n\n    return input.getValue();\n  });\n\n  input.reset = ({target = input} = {}) => {\n    if (target === input && input.isPendingBlocked) {\n      return;\n    }\n\n    if (children) {\n      children.forEach((child) => child.reset({target}));\n    }\n\n    resetInternal();\n\n    if (target === input) {\n      input.root.markAsDirty();\n      input.root.validate({event: 'reset', target: input});\n\n      // after validation must recheck if it's pending blocked\n      if (input.actions && input.actions.reset && !input.isPendingBlocked) {\n        input.actions.reset.call(input);\n      }\n    }\n  };\n\n  const resetInternal = () => {\n    setValue.call(input, input.initialValue);\n\n    input.isSubmitted = false;\n    input.isTouched = false;\n  };\n\n  input.clear = ({target = input} = {}) => {\n    if (target === input && input.isPendingBlocked) {\n      return;\n    }\n\n    if (children) {\n      children.forEach((child) => child.clear({target}));\n    }\n\n    if (config.hasOwnProperty('clearValue')) {\n      input.initialValue = clearValue;\n    } else if (input.initialValue) {\n      input.initialValue = null;\n    }\n\n    resetInternal();\n\n    if (target === input) {\n      input.root.markAsDirty();\n      input.root.validate({event: 'clear', target: input});\n\n      // after validation must recheck if it's pending blocked\n      if (input.actions && input.actions.clear && !input.isPendingBlocked) {\n        input.actions.clear.call(input);\n      }\n    }\n  };\n\n  input.get = ignore((name) => childrenMap.get(name));\n\n  input.add = (childConfig, index) => {\n    input.addChild(new Input(childConfig), index);\n  };\n\n  input.addChild = (childInput, index) => {\n    if (childInput.parent) {\n      throw new Error('The child input already has a parent.');\n    }\n\n    childInput.parent = input;\n\n    childInput.setRoot(input.root);\n\n    if (!children) {\n      input.children = children = [];\n    }\n\n    if (isVal(index)) {\n      children.splice(index, 0, childInput);\n    } else {\n      children.push(childInput);\n    }\n\n    addChildToMap(childInput);\n    addObservedChild(input, childInput);\n\n    input.markAsInputPending();\n    input.root.markAsDirty();\n    input.root.validate({event: 'add', target: input});\n  };\n\n  input.setRoot = (root) => {\n    input.root = root;\n\n    if (children) {\n      children.forEach((child) => child.setRoot(root));\n    }\n  };\n\n  input.remove = () => {\n    if (!input.parent) {\n      throw new Error('The input doesn\\'t have a parent.');\n    }\n\n    input.parent.removeChild(input);\n  };\n\n  input.removeChild = (child) => {\n    if (!children) {\n      throw new Error('Input doesn\\'t have the child.');\n    }\n\n    const childIndex = children.indexOf(child);\n\n    if (childIndex === -1) {\n      throw new Error('Input doesn\\'t have the child.');\n    }\n\n    children.splice(childIndex, 1);\n\n    if (isVal(child.name)) {\n      childrenMap.delete(child.name);\n    }\n\n    removeObservedChild(input, child);\n\n    child.parent = null;\n\n    child.setRoot(child);\n    input.markAsInputPending();\n    input.root.markAsDirty();\n    input.root.validate({event: 'remove', target: input});\n  };\n\n  initInput();\n\n  if (init) {\n    init.call(input, {input});\n  }\n\n  return input;\n});\n\nconst Form = controller(function (config) {\n  const root = new Input(config);\n\n  root.validate({event: 'init'});\n\n  return root;\n});\n\nexport default Form;\n\nForm.asyncValidationError = 'Validation failed';\n"],"names":["debounce","func","delay","timeout","function","args","clearTimeout","setTimeout","apply","this","createElement","numberRegExp","partialNumberRegExp","integerRegExp","partialIntegerRegExp","allowedHtmlInputTypes","isBoolHtmlInputType","type","valuesNormalizer","number","value","initialValue","undefined","Number","integer","string","trim","text","textarea","valueTypesGuards","test","valueChangeGuards","oldValue","Input","constructor","super","state","props","onChange","onBlur","initOnChange","bind","setOnChangeMethod","setOnBlurMethod","componentDidUpdate","prevProps","debounceChanged","onChangeChanged","onBlurChanged","isInputPending","forceUpdate","setState","e","onStartPending","target","checked","valueTypeGuard","valueChangeGuard","normalizer","normalizedValue","inputDebounce","getInputDebounce","context","render","errors","required","placeholder","className","readOnly","disabled","autoFocus","inputClassName","inputProps","hasErrors","length","Object","assign","includes","map","error","i","key","propTypes","defaultProps","contextTypes","config","name","validate","init","actions","parent","root","onFormChange","preventInputPendingBlocking","preventPendingBlocking","getValue","setValue","children","clearValue","childrenMap","Map","isSelfInputPending","input","isDirty","isTouched","isSubmitted","isPending","isPendingBlocked","addChildToMap","child","has","Error","set","val","call","markAsInputPending","markAsDirty","markAsTouched","event","callOnFormChange","some","hasDirtyChildren","forEach","touchedInput","push","Array","isArray","Form","asyncValidationError","changeHandlingInput","pendingInput","submit","isBlocked","getResult","size","result","reset","resetInternal","clear","hasOwnProperty","get","add","childConfig","index","addChild","childInput","setRoot","splice","remove","removeChild","childIndex","indexOf","delete","initInput"],"sourceRoot":""}